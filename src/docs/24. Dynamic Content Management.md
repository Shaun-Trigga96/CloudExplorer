# Cloud Explorer: Dynamic Content Management & User Initialization Plan

## 1. Introduction

This document outlines the strategy and implementation steps for evolving the Cloud Explorer application's content management. Currently, a static script (`scripts/create-schema.ts`) pre-populates Firestore with modules (reading from local `.md` files), quizzes, exams, and sample user data.

**Goal:** Replace the static script with a dynamic system where:

1. Core learning content (Modules, Quizzes, Exams) is managed via a backend API.
2. Module content is stored as Markdown directly in Firestore.
3. Quiz and Exam questions are generated by AI (via admin action) and stored in Firestore.
4. New users are automatically initialized with necessary profile data and empty progress structures upon signup using Firebase Auth triggers.

This approach enhances scalability, maintainability, and allows for dynamic content updates without script executions or code deployments.

## 2. Core Strategy: Shared Content + User-Specific Progress

We will adopt a standard model for learning platforms:

* **Shared Content:** Global Firestore collections (`modules`, `quizzes`, `exams`) will store the definitions and content accessible to all users. Module content will be stored as Markdown text within section documents. Quiz/Exam questions, once generated, will be stored within their respective documents.
* **User Initialization:** A Firebase Cloud Function triggered by user creation (`functions.auth.user().onCreate`) will create a document for the new user in the `users` collection, initializing their profile, default settings, and *empty* `learningProgress`.
* **User-Specific Progress:** Existing backend API endpoints (`trackProgress`, `saveQuizResult`, `saveExamResult`, etc.) will record user interactions by creating documents in collections like `quizResults`, `examResults`, and the user's `progress` subcollection, linking the `userId` to the shared content IDs (`moduleId`, `quizId`, `examId`).

**Benefits:**

* **Data Efficiency:** Avoids massive duplication of content for each user.
* **Maintainability:** Shared content can be updated centrally via admin tools.
* **Scalability:** Easily handles a growing number of users and content items.

## 3. Backend Implementation (`backend/`)

The Node.js/Express backend requires updates to manage content and provide admin capabilities.

### 3.1. Authentication & Authorization Middleware (Admin Protection)

All Admin Endpoints listed below **must** be protected. Create middleware (e.g., `backend/middleware/authMiddleware.js`) to:

1. **Verify Firebase ID Token:** Use `admin.auth().verifyIdToken(token)` to authenticate the request.
2. **Check Admin Role:** Verify if the authenticated user has admin privileges. This can be done by checking:
    * A custom claim set on the user's token (e.g., `decodedToken.admin === true`). Custom claims are set using the Admin SDK.
    * A specific field in the user's Firestore document (e.g., `/users/{userId}.role === 'admin'`).
3. Reject requests from non-authenticated or non-admin users with a 401 or 403 status.

**Conceptual Example (`backend/middleware/authMiddleware.js`):**

```javascript
const admin = require('firebase-admin');
const AppError = require('../utils/appError'); // Assuming AppError setup

// Middleware to verify Firebase token and user existence
const protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return next(new AppError('No token provided. Authentication required.', 401, 'AUTH_NO_TOKEN'));
  }

  try {
    const decodedToken = await admin.auth().verifyIdToken(token);
    req.user = decodedToken; // Attach user info to the request object

    // Optional: Check if user exists in Firestore DB (might be redundant if Auth is source of truth)
    // const userDoc = await admin.firestore().collection('users').doc(req.user.uid).get();
    // if (!userDoc.exists) {
    //    return next(new AppError('User associated with token not found.', 401, 'AUTH_USER_NOT_FOUND'));
    // }

    next();
  } catch (error) {
    console.error('Token verification failed:', error.message);
    return next(new AppError('Invalid or expired token. Please log in again.', 401, 'AUTH_INVALID_TOKEN'));
  }
};

// Middleware to check for Admin role (example using custom claims)
const adminOnly = (req, res, next) => {
  if (req.user && req.user.admin === true) { // Check for custom claim 'admin'
    next();
  } else {
    // Check Firestore role if not using custom claims (requires another DB read)
    // Example: checkUserRole(req.user.uid, 'admin').then(isAdmin => ...)
    return next(new AppError('Access denied. Admin privileges required.', 403, 'AUTH_ADMIN_REQUIRED'));
  }
};

module.exports = { protect, adminOnly };
```

**Note**: Implement the role-checking mechanism (custom claims or Firestore field) based on your preference.

### 3.2. Admin Endpoints

Add the following routes and controller logic. Remember to apply the **protect** and **adminOnly** middleware in the router files.

#### A. Module Endpoints

(In **backend/controllers/moduleController.js** & **backend/routes/moduleRoutes.js**)

* **POST /api/v1/modules** (**Admin**)
  * **Body**: { **title: string, description: string, duration?: number, prerequisites?: string[], sections: [{ title: string, content: string (Markdown), order: number** }] }
  * Logic: Creates module doc & section subcollection docs with Markdown content.
  * Example Controller Snippet (**moduleController.js**):

```javascript
exports.createModuleWithSections = async (req, res, next) => {
    try {
        const { title, description, duration, prerequisites, sections } = req.body;

        // --- Validation ---
        if (!title || typeof title !== 'string' || title.trim() === '') {
            return next(new AppError('Module title is required.', 400, 'VALIDATION_ERROR'));
        }
        if (!description || typeof description !== 'string') {
             return next(new AppError('Module description is required.', 400, 'VALIDATION_ERROR'));
        }
         if (!Array.isArray(sections) || sections.length === 0) {
             return next(new AppError('Module must have at least one section.', 400, 'VALIDATION_ERROR'));
         }
         // Add more validation for section content, order, etc.

        const moduleId = title.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''); // Basic ID generation
        const moduleRef = db.collection('modules').doc(moduleId);

        const moduleData = {
            moduleId, // Store ID in document too
            title,
            description,
            duration: duration || null,
            prerequisites: prerequisites || [],
            contentType: 'markdown', // Indicate content type
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
            // quizIds: [], // Initialize empty quiz array?
        };

        // Use a batch for atomicity
        const batch = db.batch();
        batch.set(moduleRef, moduleData);

        sections.forEach((section, index) => {
            if (!section.title || !section.content || section.order === undefined) {
                throw new AppError(`Section ${index} is missing title, content, or order.`, 400, 'VALIDATION_ERROR');
            }
            const sectionRef = moduleRef.collection('sections').doc(`section-${section.order}`); // Or auto-ID
            batch.set(sectionRef, {
                title: section.title,
                content: section.content, // Store Markdown directly
                order: section.order,
                moduleId: moduleId, // Link back to module
            });
        });

        await batch.commit();
        console.log(`Admin: Created module ${moduleId} with ${sections.length} sections.`);

        res.status(201).json({ ...moduleData, moduleId: moduleRef.id, sections }); // Return created data

    } catch (error) {
        if (!error.isOperational && error.message?.includes('firestore')) {
            next(new AppError(`Database error creating module: ${error.message}`, 500, 'DB_SAVE_ERROR'));
        } else {
           next(error);
        }
    }
};

```

* **PUT /api/v1/modules/:moduleId** (**Admin**)
  * **Body**: Partial module data, including optional **sections** array.
  * **Logic**: Updates module doc. Handles section updates (overwrite or merge logic required).
* **DELETE /api/v1/modules/:moduleId** (**Admin**)
  * **Logic**: Deletes module doc. Requires separate logic (e.g., Cloud Function trigger or client-side iteration) to reliably delete the **sections** subcollection.

#### B. Quiz Endpoints

(In **backend/controllers/quizController.js** & **backend/routes/quizRoutes.js**)

* **POST /api/v1/quizzes/generate-and-save** (**Admin, Rate Limited**)
* **Body**: **:{ moduleId: string, title?: string, passingScore?: number, numberOfQuestions?: number, questionTypes?: string[] }**:
* **:Logic**: Fetches module content from Firestore, calls AI to generate questions, parses response, saves questions to a new document in **quizzes** collection, links to**moduleId**.
Example Controller Snippet (quizController.js):

```javascript
  exports.generateAndSaveQuiz = async (req, res, next) => {
    try {
        const { moduleId, title, passingScore = 70, numberOfQuestions = 5, questionTypes = ['multiple choice', 'true or false'] } = req.body;

        // --- Validation ---
        if (!moduleId) return next(new AppError('moduleId is required.', 400, 'VALIDATION_ERROR'));
         // Add other validations...

        // --- Fetch Module Content Context (from Firestore) ---
         const moduleRef = db.collection('modules').doc(moduleId);
         const moduleDoc = await moduleRef.get();
         if (!moduleDoc.exists) return next(new AppError(`Module ${moduleId} not found.`, 404, 'MODULE_NOT_FOUND'));
         const moduleData = moduleDoc.data();
         const sectionsSnapshot = await moduleRef.collection('sections').orderBy('order').get();
         let moduleContentContext = moduleData.description || '';
         sectionsSnapshot.forEach(doc => { moduleContentContext += ` ${doc.data().content || ''}`; });
         moduleContentContext = moduleContentContext.trim();
         if (!moduleContentContext) return next(new AppError(`No content found for module ${moduleId}.`, 404, 'MODULE_CONTENT_NOT_FOUND'));
         const quizTitle = title || `${moduleData.title || 'Module'} Quiz`;

        // --- Prepare AI Prompt ---
        const prompt = `Generate exactly ${numberOfQuestions} quiz questions based on: """${moduleContentContext}"""... [rest of prompt]`;

        // --- Call AI with Retry ---
         let generatedText = '';
         try {
             const result = await executeWithRetry(() => hf.textGeneration({ /* ... model, inputs: prompt, params ... */ }), 3, 15000);
             generatedText = result.generated_text;
         } catch (apiError) {
             throw new AppError(`AI model failed to generate quiz: ${apiError.message}`, 503, 'AI_SERVICE_ERROR');
         }

        // --- Parse Response ---
        const questions = parseQuizFromAIResponse(generatedText);
         if (questions.length === 0) {
            throw new AppError('Failed to parse valid quiz questions from AI.', 500, 'AI_RESPONSE_PARSE_FAILED');
         }

        // --- Save to Firestore ---
        const quizRef = db.collection('quizzes').doc(); // Auto-generate ID
        const quizData = {
            quizId: quizRef.id,
            moduleId: moduleId,
            title: quizTitle,
            passingScore: passingScore,
            questions: questions, // Store the generated questions array
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
        };
        await quizRef.set(quizData);

        // Optional: Update module doc to link quizId
        // await moduleRef.update({ quizIds: admin.firestore.FieldValue.arrayUnion(quizRef.id) });

        console.log(`Admin: Generated and saved quiz ${quizRef.id} for module ${moduleId}.`);
        res.status(201).json(quizData);

    } catch (error) {
         next(error);
    }
};
```

* **PUT /api/v1/quizzes/:quizId** (**Admin**)
  * **Body**: **{ title?, passingScore?, questions?: [...] }** a.
  * **Logic**: Updates stored quiz document. Allows manual correction of AI-generated questions.
* **DELETE /api/v1/quizzes/:quizId** (**Admin**)
  * **Logic**:  Deletes quiz document.

#### Exam Endpoints

(In **backend/controllers/examController.js & backend/routes/examRoutes.js**)

* **POST /api/v1/exams/create** (**Admin**)- Use Existing / Refine
* **Body**: **{ examId: string, title: string, description: string, duration?: number, prerequisites?: string[], associatedModules?: string[] }**:
* **:Logic**:  Saves exam metadata. Ensure **associatedModules** is saved if needed by getExamContent.

* **POST /api/v1/exams/generate-and-save** (**Admin, Rate Limited**)
  * **Body**: **{ examId: string, numberOfQuestions?: number, questionTypes?: string[] }**
  * **Logic**: Fetches exam context using **getExamContent(examId)**, calls AI, parses response, updates the **exams/{examId**} document to add/replace the **questions** array (or saves to subcollection).
Example Controller Snippet (**examController.js**):

```javascript
exports.generateAndSaveExamQuestions = async (req, res, next) => {
    try {
         const { examId, numberOfQuestions = 25, questionTypes = ['multiple choice', 'true or false'] } = req.body;

         // --- Validation ---
         if (!examId) return next(new AppError('examId is required.', 400, 'VALIDATION_ERROR'));
          // Add other validations...

         // --- Fetch Exam Context ---
         const examRef = db.collection('exams').doc(examId);
         const examDoc = await examRef.get();
         if (!examDoc.exists) return next(new AppError(`Exam ${examId} not found.`, 404, 'EXAM_DEF_NOT_FOUND'));
         const examTitle = examDoc.data().title || 'Exam';
         const examContentContext = await getExamContent(examId); // Uses helper
         if (!examContentContext || examContentContext.length < 50) {
              console.warn(`Insufficient context for exam ${examId}. Generation might be less accurate.`);
         }

         // --- Prepare AI Prompt ---
         const prompt = `Generate exactly ${numberOfQuestions} challenging exam questions for "${examTitle}" based on: """${examContentContext}"""... [rest of prompt]`;

         // --- Call AI with Retry ---
         let generatedText = '';
         try {
             const result = await executeWithRetry(() => hf.textGeneration({ /* ... model, inputs: prompt, params ... */ }), 3, 30000);
             generatedText = result.generated_text;
         } catch (apiError) {
             throw new AppError(`AI model failed to generate exam questions: ${apiError.message}`, 503, 'AI_SERVICE_ERROR');
         }

         // --- Parse Response ---
         const questions = parseQuizFromAIResponse(generatedText);
         if (questions.length === 0) {
             throw new AppError('Failed to parse valid exam questions from AI.', 500, 'AI_RESPONSE_PARSE_FAILED');
         }

         // --- Save Questions to Firestore ---
         // Option 1: Update the main exam document
         await examRef.update({
             questions: questions, // Add/overwrite questions array
             questionsGeneratedAt: serverTimestamp(), // Track generation time
             updatedAt: serverTimestamp()
         });
         // Option 2: Save to subcollection (e.g., exams/{examId}/generatedQuestions/{docId})
         // const questionsRef = examRef.collection('generatedQuestions').doc(); // Or use a specific ID
         // await questionsRef.set({ questions, generatedAt: serverTimestamp() });

         console.log(`Admin: Generated and saved questions for exam ${examId}.`);
         res.status(200).json({ examId, title: examTitle, questions }); // Return generated questions

    } catch (error) {
        next(error);
    }
};
```

* **PUT /api/v1/exams/:examId** **(Admin)**
  * **Body**: Partial exam metadata and/or **questions** array.
  * **Logic**: Updates exam doc/subcollection.
* **DELETE /api/v1/exams/:examId** **(Admin)**
  * **Logic**: Deletes exam doc (and potentially questions subcollection).

### 3.3. Updated Routers

Ensure the new admin routes are added to **moduleRoutes.js**, **quizRoutes.js**, **examRoutes.js** and protected using the **protect** and **adminOnly** middleware.

**Example** (**quizRoutes.js**):

```javascript
const express = require('express');
const quizController = require('../controllers/quizController');
const { hfApiLimiter } = require('../server'); // Import limiter
const { protect, adminOnly } = require('../middleware/authMiddleware'); // Import auth middleware

const router = express.Router();

// --- Admin Routes ---
router.post('/generate-and-save', protect, adminOnly, hfApiLimiter, quizController.generateAndSaveQuiz);
router.put('/:quizId', protect, adminOnly, quizController.updateStoredQuiz); // Assuming updateStoredQuiz exists
router.delete('/:quizId', protect, adminOnly, quizController.deleteStoredQuiz); // Assuming deleteStoredQuiz exists

// --- User Routes ---
router.post('/save-result', protect, quizController.saveQuizResult);
router.get('/history/:userId', protect, quizController.getQuizHistory); // Or move to userRoutes
// Maybe a route to GET a specific stored quiz for taking?
// router.get('/:quizId/take', protect, quizController.getQuizForTaking);

module.exports = router;
```

(Apply similar patterns to other router files)

### 3.4. Utility Functions

* Ensure the utility functions are correctly placed and imported:

* **backend/utils/appError.js**: Centralized error class.
* **backend/utils/retryHandler.js**: **executeWithRetry** function.
* **backend/utils/aiHelpers.js**: **parseQuizFromAIResponse**, **getExamContent** functions.
* **backend/utils/firestoreHelpers.js**: **serverTimestamp**.
* **backend/utils/googleAuth.js**: **authenticateGoogleDocs**.

### 3.5. Server Configuration (server.js)

* **Make sure server.js**:

* Initializes **admin** SDK.
* Initializes **HfInference** and exports **hf**.
* Defines and exports **hfApiLimiter**.
* Mounts all routers (**userRoutes**, **moduleRoutes**, **quizRoutes**, **examRoutes**, etc.) under **/api/v1**.
* Includes the global error handler middleware last.

### 4. Admin Interface Implementation (Frontend)

A separate web-based Admin Interface is required to interact with the new backend Admin Endpoints.

* **Purpose**: Provide a UI for administrators to manage modules (create/edit Markdown content), manage exams (create metadata, trigger AI generation, edit), and manage quizzes (trigger AI generation, edit).

* **Technology Stack**: Recommended: React (matches React Native skills), Vue, Angular, or similar web framework. Can use component libraries like Material UI, Ant Design for faster UI development.

* **Key Features**:
  * Admin Login (using Firebase Authentication).
  * Dashboard/Navigation.
  * **Module Management**:
    * List existing modules.
    * Form to create a new module (inputs for title, description, etc.).
    * Rich Text/Markdown editor (e.g., react-markdown, react-mde) for creating/editing section content within the form.
    * Ability to add/remove/reorder sections.
    * Edit existing modules.
    * Delete modules.

* **Exam Management**:
  * List existing exams.
  * Form to create/edit exam metadata (title, description, duration, associatedModules).
  * Button to "Generate/Regenerate Exam Questions" (calls POST /api/v1/exams/generate-and-save).
  * Display area to view/potentially edit the stored generated questions.
  * Delete exams.

* **Quiz Management**:
  *List existing stored quizzes.
  *Mechanism to select a Module and trigger Quiz generation (calls POST /api/v1/quizzes/generate-and-save).
  *Display area to view/edit stored quiz questions.
  *Delete quizzes.

* **Alternatives**: As mentioned before, low-code tools (Retool, Appsmith) or simply using API clients (Postman) can be intermediate steps, but a dedicated interface is best for usability.

### 5. User Initialization (functions/)

Implement the Firebase Auth **onCreate** trigger to automatically create Firestore documents for new users.

Add this code to functions/index.js:

```javascript
// functions/index.js (or functions/src/index.js)

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const sgMail = require('@sendgrid/mail');

// Initialize Admin SDK (runs only once on cold start)
try {
  if (admin.apps.length === 0) { // Prevent re-initialization
       admin.initializeApp();
  }
} catch (e) {
  console.error('Firebase admin initialization error', e);
}
const db = admin.firestore(); // Define db globally here

// Set SendGrid API Key
try {
    sgMail.setApiKey(functions.config().sendgrid.key);
} catch (e) {
    console.error('SendGrid API key configuration error. Make sure functions config sendgrid.key is set.', e);
}


// --- Existing Callable Function ---
exports.updateEmailSubscription = functions.https.onCall(async (data, context) => {
  // ... (your existing, refined code) ...
});

// --- NEW Auth Trigger Function ---
exports.initializeNewUser = functions.auth.user().onCreate(async (user) => {
    functions.logger.log(`Initializing Firestore document for new user: ${user.uid} (${user.email})`);

    const userRef = db.collection('users').doc(user.uid);

    // Default data for a new user
    const newUserProfile = {
        uid: user.uid,
        email: user.email || null,
        displayName: user.displayName || 'New User',
        photoURL: user.photoURL || 'YOUR_DEFAULT_AVATAR_URL_HERE', // <-- SET A DEFAULT URL
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        bio: '',
        lastLogin: admin.firestore.FieldValue.serverTimestamp(),
        learningProgress: {
            completedModules: [],
            completedQuizzes: [],
            completedExams: [],
            score: 0,
        },
        settings: {
            notificationsEnabled: true,
            darkMode: false,
            emailUpdates: true,
            syncData: true,
            soundEffects: false,
        },
    };

    try {
        await userRef.set(newUserProfile);
        functions.logger.log(`Successfully created Firestore user document for ${user.uid}`);

        // Optional: Create a welcome notification
        const notificationRef = db.collection('notifications').doc(); // Auto-ID
        await notificationRef.set({
             notificationId: notificationRef.id,
             userId: user.uid,
             title: 'Welcome to Cloud Explorer!',
             message: 'Start your cloud learning journey today!',
             type: 'welcome',
             read: false,
             createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        functions.logger.log(`Welcome notification created for ${user.uid}`);

    } catch (error) {
        functions.logger.error(`Error creating Firestore user document for ${user.uid}:`, error);
    }
});
```

* **Deployment**:

1. Make sure you have the Firebase CLI installed and configured.
2. Navigate to your project root in the terminal.
3. Run: firebase deploy --only functions

### 6. Transition Plan

1. Implement Backend Admin Endpoints: Build and test the new protected endpoints in your Node.js/Express backend for managing modules, quizzes, and exams.
2. Implement Auth Trigger: Add and deploy the initializeNewUser Cloud Function.
3. Build Admin Interface: Create the admin frontend to interact with the new backend endpoints.
4. Initial Content Seed (Optional, One-Time):

   * Adapt your old create-schema.ts script (remove cleanup, user creation, progress sections).
   * Modify it to read your .md files and call your new POST /api/v1/modules endpoint for each module.
   * Modify it to call your new POST /api/v1/exams/create endpoint for each exam's metadata.
   * Modify it to call your new POST /api/v1/quizzes/generate-and-save and POST /api/v1/exams/generate-and-save endpoints once for each initial quiz/exam to populate the stored questions.
   * Run this adapted script once against your development/staging environment, then production, after the backend endpoints and auth trigger are deployed.

5. Retire Old Script: Remove or archive the original create-schema.ts script to prevent accidental execution.
6. Frontend API Updates: Ensure your React Native application is updated to use the correct /api/v1/... endpoints for fetching content and posting results, as discussed previously.

7. Conclusion

By implementing these changes, Cloud Explorer will transition to a robust, scalable system. Content management becomes centralized and dynamic via admin tools, and user initialization is automated. This lays a solid foundation for future growth and feature additions.

Okay, I've analyzed the `create-schema-content-only.ts` script you provided. It defines the structure for your modules, quizzes, and exams, reads content from local Markdown files, uses Hugging Face to generate questions, and seeds everything into Firestore.

Here's a strategy to refactor this logic into individual, maintainable Cloud Functions, separating the concerns as you requested:

**1. Core Cloud Functions:**

We'll create three main Cloud Functions, likely HTTP-triggered for easy updates via an admin interface or CI/CD pipeline:

* **`manageModuleContent` (HTTP Triggered):**
  * **Purpose:** Handles creating or updating a single module and its associated sections.
  * **Input:** Module metadata (`moduleId`, `title`, `description`, etc.) and section data (either direct Markdown content or references to content stored elsewhere, like Cloud Storage).
  * **Logic:** Adapts the `seedModules` logic from your script. It will:
    * Write/update the module document in the `modules` collection in Firestore.
    * Read section content (see Point 3 below).
    * Create/overwrite corresponding section documents in the `sections` subcollection under the module.
* **`generateQuiz` (HTTP Triggered or Pub/Sub):**
  * **Purpose:** Generates and saves quiz questions for a specific module. Could be triggered manually (HTTP) or automatically when a module's content changes (Pub/Sub trigger listening to Firestore updates or Cloud Storage changes).
  * **Input:** Quiz definition (`quizId`, `moduleId`, `title`, `numberOfQuestions`, `passingScore`).
  * **Logic:** Adapts the `generateAndSaveQuizQuestions` logic:
    * Fetch the relevant module's content (from Firestore sections or Cloud Storage).
    * Construct the prompt for the Hugging Face API.
    * Call the Hugging Face API (using `executeWithRetry`).
    * Parse the response (`parseQuizFromAIResponse`).
    * Save/update the quiz document in the `quizzes` collection.
    * Link the `quizId` back to the module document.
* **`generateExam` (HTTP Triggered):**
  * **Purpose:** Handles creating/updating exam metadata and generating its questions.
  * **Input:** Exam definition (`examId`, `title`, `description`, `associatedModules`, `numberOfQuestions`, etc.).
  * **Logic:** Adapts `seedExamMetadata` and `generateAndSaveExamQuestions`:
    * Create/update the exam metadata document in the `exams` collection.
    * Fetch content context from *all* associated modules (`getExamContent` logic).
    * Construct the prompt and call the Hugging Face API.
    * Parse the response.
    * Update the exam document with the generated questions and timestamp.

**2. Shared Code and Configuration:**

* **`functions/src/config/`:** Place shared configurations like Firebase Admin SDK initialization (similar to your existing `config.js`), Hugging Face client initialization, logger setup, and environment variable handling here.
* **`functions/src/types/`:** Store your shared TypeScript interfaces (Module, Section, Quiz, Exam, Question) here.
* **`functions/src/utils/`:** Move reusable utility functions like `executeWithRetry`, `parseQuizFromAIResponse`, and `getExamContent` into this directory. You might also add helpers for reading content (see Point 3).

**3. Handling Content Files (.md):**

Cloud Functions cannot directly read local file paths (`fs.readFileSync`) like your script does after deployment. The recommended approach is:

* **Store Markdown in Google Cloud Storage:** Upload your `.md` files to a dedicated Cloud Storage bucket.
* **Update Functions:** Modify the `manageModuleContent` function (and potentially `generateQuiz`/`generateExam` if they need raw content) to read the necessary Markdown files from the specified Cloud Storage paths instead of the local filesystem. You'll use the Cloud Storage client library for Node.js (`@google-cloud/storage`). Create a utility function in `functions/src/utils/storageUtils.ts` for this.

**4. Proposed `functions/src` Structure:**

```
functions/
├── src/
│   ├── manageModuleContent/  # Function for modules/sections
│   │   └── index.ts
│   ├── generateQuiz/         # Function for quizzes
│   │   └── index.ts
│   ├── generateExam/         # Function for exams
│   │   └── index.ts
│   ├── config/
│   │   └── config.ts         # Firebase/HF Init, Env Vars, Logger
│   ├── types/
│   │   └── index.ts          # Shared Interfaces (Module, Quiz, etc.)
│   ├── utils/
│   │   ├── aiUtils.ts        # parseQuiz, executeWithRetry, getExamContent
│   │   ├── firestoreUtils.ts # Optional Firestore helpers
│   │   └── storageUtils.ts   # Helper to read from Cloud Storage
│   ├── index.ts              # Exports all Cloud Functions
├── package.json
├── tsconfig.json
└── .env.local              # For local Firebase emulation env vars
```

**Next Steps:**

1. Set up the new directory structure within `functions/src`.
2. Move shared types, config initializers, and utility functions.
3. Implement the logic for each of the three Cloud Functions, adapting code from your `create-schema-content-only.ts` script.
4. Replace filesystem reads (`fs.readFileSync`) with Cloud Storage reads.
5. Configure necessary environment variables (like `SENDGRID_KEY`, `HUGGINGFACE_API_KEY`, `FIREBASE_SERVICE_ACCOUNT_PATH` or rely on default credentials, Cloud Storage bucket name) for the Cloud Functions environment.
6. Deploy and test each function individually.

This approach breaks down the monolithic script into manageable, independent functions, leveraging the cloud environment effectively for content updates. Let me know if you'd like a more detailed code snippet for a specific part of this refactoring!

Okay, I can provide you with the TypeScript code for the Cloud Functions structure we discussed.

**Important Setup Notes:**

1. **Directory Structure:** Create the following structure inside your `functions/` directory:

    ```
    functions/
    ├── src/
    │   ├── manageModuleContent/
    │   ├── generateQuiz/
    │   ├── generateExam/
    │   ├── config/
    │   ├── types/
    │   ├── utils/
    │   ├── index.ts
    ├── package.json
    ├── tsconfig.json
    └── .env.local  # Optional: For local emulation variables
    ```

2. **Dependencies:** Ensure your `functions/package.json` includes these dependencies:
    * `firebase-admin`
    * `firebase-functions`
    * `@google-cloud/storage`
    * `@huggingface/inference`
    * `dotenv` (optional, primarily for local emulation if using `.env.local`)
    Run `npm install` within the `functions` directory.
3. **Environment Variables:** You **must** configure environment variables for your deployed functions. Use the Firebase CLI:

    ```bash
    firebase functions:config:set config.sendgrid_key="YOUR_SENDGRID_API_KEY" # If needed by other functions
    firebase functions:config:set config.hf_key="YOUR_HUGGINGFACE_API_KEY"
    firebase functions:config:set config.hf_model_quiz="mistralai/Mistral-7B-Instruct-v0.2" # Or your preferred model
    firebase functions:config:set config.hf_model_exam="mistralai/Mistral-7B-Instruct-v0.2" # Or your preferred model
    firebase functions:config:set config.storage_bucket="your-gcp-project-id.appspot.com" # Default bucket, or specify yours
    ```

    *Replace placeholders with your actual values.* For local emulation, you can create a `functions/.env.local` file (ensure it's in `.gitignore`):

    ```.env.local
    SENDGRID_KEY=YOUR_SENDGRID_API_KEY
    HUGGINGFACE_API_KEY=YOUR_HUGGINGFACE_API_KEY
    HF_MODEL_QUIZ=mistralai/Mistral-7B-Instruct-v0.2
    HF_MODEL_EXAM=mistralai/Mistral-7B-Instruct-v0.2
    STORAGE_BUCKET=your-gcp-project-id.appspot.com
    # If not using default credentials, specify the service account path relative to functions dir
    # FIREBASE_SERVICE_ACCOUNT_PATH=./path/to/serviceAccountKey.json
    ```

4. **Cloud Storage:** Create a folder (e.g., `module_content/`) in your Google Cloud Storage bucket (`your-gcp-project-id.appspot.com` or the one you configured) and upload your `.md` content files there. The function code assumes paths like `module_content/fundamentalCloudConceptsNotes.md`.
5. **IAM Permissions:** Ensure the service account your Cloud Functions run as (usually `PROJECT_ID@appspot.gserviceaccount.com`) has roles like:
    * `roles/datastore.user` (for Firestore access)
    * `roles/storage.objectViewer` (to read from Cloud Storage)
    * Any roles needed for other services your functions might use.

---

**Code Snippets:**

**1. `functions/src/types/index.ts`**

```typescript
import { FieldValue, Timestamp } from 'firebase-admin/firestore';

// Replicates types from your script, ensure they match Firestore structure

export interface Section {
    id: string; // Ensure ID is always present when writing
    title: string;
    content: string; // Markdown content read from storage
    order: number;
    moduleId: string;
    createdAt?: Timestamp | FieldValue; // Add timestamps
    updatedAt?: Timestamp | FieldValue;
}

export interface Module {
    moduleId: string;
    title: string;
    description: string;
    duration: number | null;
    prerequisites: string[];
    contentType: 'markdown' | 'google_doc'; // Consistent type
    quizIds?: string[];
    createdAt?: Timestamp | FieldValue;
    updatedAt?: Timestamp | FieldValue;
    // Sections are stored in a subcollection, not directly on the module doc
}

export interface Question {
    id: number; // Or string if needed
    question: string;
    answers: { letter: string; answer: string; uniqueKey: string }[];
    correctAnswer: string;
    explanation: string;
}

export interface Quiz {
    quizId: string;
    moduleId: string;
    title: string;
    questions: Question[];
    passingScore: number;
    createdAt?: Timestamp | FieldValue;
    updatedAt?: Timestamp | FieldValue;
}

export interface Exam {
    examId: string;
    title: string;
    description: string;
    duration: number | null;
    prerequisites: string[];
    associatedModules?: string[];
    questions?: Question[];
    questionsGeneratedAt?: Timestamp | FieldValue;
    createdAt?: Timestamp | FieldValue;
    updatedAt?: Timestamp | FieldValue;
}

// --- Input types for HTTP functions ---

export interface ModuleInputSection {
    title: string;
    // Path within the bucket/folder (e.g., 'module_content/intro.md')
    contentStoragePath: string;
    order: number;
}

export interface ManageModuleInput {
    moduleId: string;
    title: string;
    description: string;
    duration?: number | null;
    prerequisites?: string[];
    sections: ModuleInputSection[];
}

export interface GenerateQuizInput {
    quizId: string;
    moduleId: string;
    title: string;
    numberOfQuestions: number;
    passingScore: number;
}

export interface GenerateExamInput {
    examId: string;
    title: string;
    description: string;
    duration?: number | null;
    prerequisites?: string[];
    associatedModules?: string[];
    numberOfQuestions: number;
}

```

**2. `functions/src/config/config.ts`**

```typescript
import * as admin from 'firebase-admin';
import * as functions from 'firebase-functions';
import { HfInference } from '@huggingface/inference';
import { defineString } from 'firebase-functions/params';

// --- Firebase Admin SDK Initialization ---
try {
    // Check if already initialized (useful for local testing where script might run multiple times)
    if (admin.apps.length === 0) {
        // If service account path is specified in .env for local dev, use it
        // Otherwise, rely on default credentials in Cloud Functions environment
        const serviceAccountPath = process.env.FIREBASE_SERVICE_ACCOUNT_PATH;
        if (serviceAccountPath) {
            const serviceAccount = require(serviceAccountPath); // Requires path relative to functions dir
            admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
            });
            functions.logger.info('Firebase Admin SDK initialized using service account file.');
        } else {
            admin.initializeApp(); // Use default credentials
            functions.logger.info('Firebase Admin SDK initialized using default credentials.');
        }
    }
} catch (e: any) {
    if (!e.message?.includes('already exists')) {
        functions.logger.error('Firebase Admin SDK initialization error in config.ts', e);
        // Decide if you want to throw or let functions potentially fail later
    } else {
         functions.logger.info('Firebase Admin SDK already initialized (config.ts).');
    }
}

// --- Define Parameters (using new param system) ---
// Access these in functions using .value()
const huggingFaceApiKey = defineString('CONFIG_HF_KEY'); // Name matches firebase functions:config:set key
const storageBucketName = defineString('CONFIG_STORAGE_BUCKET');
// Define models if you want them configurable
const hfModelQuiz = defineString('CONFIG_HF_MODEL_QUIZ');
const hfModelExam = defineString('CONFIG_HF_MODEL_EXAM');

// --- Export Shared Resources ---
export const db = admin.firestore();
export const storage = admin.storage(); // Export storage instance
export const logger = functions.logger;

// --- Hugging Face Client Initialization ---
// Initialize HF client - ensure API key is available
let hfClient: HfInference | null = null;
try {
    // Note: .value() only works reliably *inside* a function context at runtime.
    // For initializing here, we might need to rely on process.env for local or function config directly.
    // Using process.env for simplicity here, assuming config:set populates it.
    const apiKey = process.env.CONFIG_HF_KEY || functions.config().config?.hf_key; // Fallback for older config access
    if (!apiKey) {
         logger.warn('Hugging Face API Key (CONFIG_HF_KEY) not found in environment/config. Client not initialized.');
    } else {
        hfClient = new HfInference(apiKey);
        logger.info('Hugging Face client initialized.');
    }
} catch (error: any) {
    logger.error('CRITICAL: Failed to initialize Hugging Face client:', error.message);
    // Decide if this is fatal for your functions
}

export { hfClient, huggingFaceApiKey, storageBucketName, hfModelQuiz, hfModelExam }; // Export client and params

// Utility function for server timestamps
export const serverTimestamp = () => FieldValue.serverTimestamp();

// Import FieldValue correctly where needed
import { FieldValue } from 'firebase-admin/firestore';

```

**3. `functions/src/utils/storageUtils.ts`**

```typescript
import { storage, logger, storageBucketName } from '../config/config'; // Import shared storage and logger

/**
 * Reads a text file (like Markdown) from Google Cloud Storage.
 * @param filePath The path to the file within the bucket (e.g., 'module_content/intro.md').
 * @returns The content of the file as a string.
 * @throws Throws an error if the file cannot be read.
 */
export async function readFromStorage(filePath: string): Promise<string> {
    const bucketName = storageBucketName.value(); // Get bucket name from params
     if (!bucketName) {
        logger.error('Storage bucket name (CONFIG_STORAGE_BUCKET) is not configured.');
        throw new Error('Storage bucket name not configured.');
    }
    const bucket = storage.bucket(bucketName);
    const file = bucket.file(filePath);

    logger.info(`Attempting to read from gs://${bucketName}/${filePath}`);

    try {
        const [content] = await file.download();
        logger.info(`Successfully read file: ${filePath}`);
        return content.toString('utf8');
    } catch (error: any) {
        logger.error(`Failed to read file from storage gs://${bucketName}/${filePath}:`, error.message);
        // Check for common errors like 'file not found'
        if (error.code === 404) {
            throw new Error(`File not found at path: ${filePath}`);
        }
        throw new Error(`Could not read file ${filePath}: ${error.message}`);
    }
}
```

**4. `functions/src/utils/aiUtils.ts`**

```typescript
import { logger, db, hfClient, hfModelQuiz, hfModelExam } from '../config/config'; // Import shared logger, db, hfClient
import { Question } from '../types'; // Import Question type
import * as admin from 'firebase-admin'; // Import admin for db instance type

/**
 * Executes an async function with retry logic for transient errors.
 */
export async function executeWithRetry<T>(
    fn: () => Promise<T>,
    maxRetries = 3,
    timeout = 30000, // Increased default timeout
    initialDelay = 1500
): Promise<T> {
    logger.info(`>> Calling function with retry (max ${maxRetries}, timeout ${timeout}ms)...`);
    let lastError: Error | null = null;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            const timeoutPromise = new Promise<T>((_, reject) => {
                const timer = setTimeout(() => reject(new Error(`Operation timed out after ${timeout}ms`)), timeout);
                // Allow Node.js to exit if this is the only thing running
                if (typeof timer.unref === 'function') {
                   timer.unref();
                }
            });
            // Use type assertion if Promise.race result type is ambiguous
            return await Promise.race([fn(), timeoutPromise]) as T;
        } catch (error: any) {
            lastError = error;
            // Add more specific error codes if needed from HF or network issues
            const isRetryable = error.message?.includes('RESOURCE_EXHAUSTED')
                             || error.status === 429 // Too Many Requests
                             || error.status === 503 // Service Unavailable
                             || error.name === 'AbortError'
                             || error.message?.includes('timeout')
                             || error.message?.includes('Too Many Requests')
                             || error.message?.includes('Rate limit reached');

            if (isRetryable && attempt < maxRetries - 1) {
                const delay = initialDelay * (2 ** attempt);
                logger.warn(`!! Attempt ${attempt + 1} failed: ${error.message}. Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                logger.error(`!! Attempt ${attempt + 1} failed permanently: ${error.message}`);
                throw error; // Rethrow the error
            }
        }
    }
    // This should ideally not be reached if throw happens above, but satisfies TS compiler
    logger.error('All retry attempts failed.');
    throw lastError ?? new Error('All retry attempts failed, but no specific error was captured.');
}


/**
 * Parses the raw text response from Hugging Face into structured Question objects.
 * NOTE: This requires your specific parsing logic. The example below is a placeholder.
 */
export function parseQuizFromAIResponse(text: string): Question[] {
    logger.info(`>> Parsing AI response (${(text || '').length} chars)...`);
    if (!text) return [];

    // ========================================================================
    // >>> PASTE YOUR ACTUAL PARSING LOGIC HERE <<<
    // This needs to be robust to handle variations in the AI's output format.
    // It should extract the question text, multiple choice answers (A, B, C, D),
    // the correct answer letter, and the explanation for each question.
    // Example structure to aim for:
    const questions: Question[] = [];
    try {
        // Placeholder: Split by question number or a clear delimiter
        const questionBlocks = text.split(/\n\d+\.\s/); // Example split, needs refinement

        questionBlocks.forEach((block, index) => {
            if (!block.trim()) return;

            // Extract question text (example)
            const questionMatch = block.match(/(.*?)\n\s*A\)/);
            const questionText = questionMatch ? questionMatch[1].trim() : `Placeholder Question ${index + 1}`;

            // Extract answers (example)
             const answers: Question['answers'] = [];
             const answerMatches = block.matchAll(/\n\s*([A-D])\)\s(.*?)(?=\n\s*[A-D]\)|$)/g);
             for (const match of answerMatches) {
                 const letter = match[1];
                 const answer = match[2].trim();
                 answers.push({ letter, answer, uniqueKey: `q${index}-${letter}` });
             }

            // Extract correct answer (example)
             const correctMatch = block.match(/\nCorrect Answer:\s*([A-D])/);
             const correctAnswer = correctMatch ? correctMatch[1] : 'A'; // Default if not found

            // Extract explanation (example)
             const explanationMatch = block.match(/\nExplanation:\s*(.*)/);
             const explanation = explanationMatch ? explanationMatch[1].trim() : 'Placeholder explanation.';

             if (answers.length > 0) { // Basic validation
                 questions.push({
                    id: index + 1, // Simple ID based on order
                    question: questionText,
                    answers: answers,
                    correctAnswer: correctAnswer,
                    explanation: explanation,
                 });
            } else {
                logger.warn(`Could not parse answers for question block ${index + 1}`);
            }
        });

    } catch (parseError: any) {
        logger.error("Error during AI response parsing:", parseError.message);
        // Optionally return partial results or an empty array
        return [];
    }
     // ========================================================================

    logger.info(`>> Parsed ${questions.length} questions.`);
    if (questions.length === 0 && text.length > 10) {
         logger.warn("Parsing resulted in 0 questions, check AI output format and parsing logic. Raw text:", text.substring(0, 500));
    }
    return questions;
}


/**
 * Fetches content context for an exam based on its description and associated module content.
 */
export async function getExamContentContext(examId: string): Promise<string> {
    logger.info(`>> Fetching content context for examId: ${examId}`);
    const examRef = db.collection('exams').doc(examId);

    try {
        const examDoc = await examRef.get();
        if (!examDoc.exists) {
            logger.error(`Exam document not found: ${examId}`);
            throw new Error(`Exam definition not found for ID: ${examId}`);
        }
        const examData = examDoc.data();
        let context = examData?.description || "";

        const associatedModules = examData?.associatedModules as string[] | undefined;

        if (associatedModules && associatedModules.length > 0) {
            logger.info(`Workspaceing content from associated modules: ${associatedModules.join(', ')}`);
            // Fetch content from each associated module's sections
            for (const moduleId of associatedModules) {
                try {
                    const sectionsSnapshot = await db.collection('modules').doc(moduleId).collection('sections').orderBy('order').get();
                    if (!sectionsSnapshot.empty) {
                         context += `\n\n--- Content from Module: ${moduleId} ---\n`;
                         sectionsSnapshot.forEach(doc => {
                            context += `\n**${doc.data().title}**\n${doc.data().content || ''}\n`;
                        });
                    } else {
                        logger.warn(`No sections found for associated module: ${moduleId}`);
                    }
                } catch (moduleError: any) {
                    logger.error(`Error fetching sections for associated module ${moduleId}:`, moduleError.message);
                    // Decide whether to continue or fail if a module is missing
                }
            }
        } else {
            logger.warn(`No associated modules listed for exam ${examId}. Context will only be the description.`);
        }

        context = context.trim();
        logger.info(`>> Context fetched for exam ${examId}. Length: ${context.length} chars`);
        return context || "Default exam context if description and modules are empty."; // Provide a fallback

    } catch (error: any) {
        logger.error(`Failed to fetch context for exam ${examId}:`, error.message);
        throw error; // Rethrow the error to be handled by the calling function
    }
}

/**
 * Fetches content context for a quiz based on its module content.
 */
export async function getQuizContentContext(moduleId: string): Promise<string> {
    logger.info(`>> Fetching content context for quiz associated with moduleId: ${moduleId}`);
    const moduleRef = db.collection('modules').doc(moduleId);

    try {
        const moduleDoc = await moduleRef.get();
        if (!moduleDoc.exists) {
             logger.error(`Module document not found: ${moduleId}`);
             throw new Error(`Module definition not found for ID: ${moduleId}`);
        }
        const moduleData = moduleDoc.data();
        let context = moduleData?.description || "";

        const sectionsSnapshot = await moduleRef.collection('sections').orderBy('order').get();
        if (!sectionsSnapshot.empty) {
            sectionsSnapshot.forEach(doc => {
                 context += `\n\n**${doc.data().title}**\n${doc.data().content || ''}\n`;
            });
        } else {
            logger.warn(`No sections found for module: ${moduleId}. Context may be incomplete.`);
        }

        context = context.trim();
         if (!context) {
            logger.error(`No content context found for module ${moduleId}. Cannot generate quiz.`);
            throw new Error(`No content context could be generated for module ${moduleId}.`);
        }

        logger.info(`>> Context fetched for quiz (module ${moduleId}). Length: ${context.length} chars`);
        return context;

    } catch (error: any) {
        logger.error(`Failed to fetch context for quiz (module ${moduleId}):`, error.message);
        throw error; // Rethrow
    }
}

/**
 * Generates quiz or exam questions using the Hugging Face API.
 */
export async function generateAIQuestions(
    prompt: string,
    numQuestions: number,
    type: 'quiz' | 'exam' = 'quiz' // To select model and parameters
): Promise<Question[]> {

    if (!hfClient) {
        logger.error("Hugging Face client is not initialized. Cannot generate questions.");
        throw new Error("Hugging Face client not available.");
    }

    const model = (type === 'exam' ? hfModelExam.value() : hfModelQuiz.value()) || 'mistralai/Mistral-7B-Instruct-v0.2'; // Fallback model
    const max_new_tokens = (type === 'exam' ? 350 : 250) * numQuestions; // Adjust token estimate
    const temperature = type === 'exam' ? 0.5 : 0.6;
    const timeout = (type === 'exam' ? 45000 : 30000) * (numQuestions / 5); // Scale timeout roughly with number of Qs

    logger.info(`Generating ${numQuestions} ${type} questions using model ${model}... (Timeout: ${timeout}ms)`);
    // logger.debug("Prompt:", prompt.substring(0, 500) + "..."); // Log partial prompt

    try {
        const result = await executeWithRetry(() => hfClient!.textGeneration({ // Use non-null assertion as we checked hfClient
            model: model,
            inputs: prompt,
            parameters: {
                max_new_tokens: max_new_tokens,
                temperature: temperature,
                // Add other parameters like top_p, top_k if needed
                return_full_text: false, // Usually better to get only the generated part
            }
        }), 3, timeout); // Use calculated timeout

        if (!result || !result.generated_text) {
            logger.error("AI generation returned empty result.");
            throw new Error("AI generation failed to return text.");
        }

        logger.info(`AI generation successful. Raw response length: ${result.generated_text.length}`);
        // logger.debug("Raw AI Response:", result.generated_text.substring(0, 500) + "...");

        const questions = parseQuizFromAIResponse(result.generated_text);

        if (questions.length === 0) {
            logger.error('AI response parsing failed or returned no questions. Check parsing logic and AI model output format.');
            // Consider throwing an error or returning empty depending on desired behavior
            throw new Error('Failed to parse questions from AI response.');
        }
         if (questions.length < numQuestions) {
            logger.warn(`AI generated ${questions.length} questions, but ${numQuestions} were requested. Check prompt and model capacity.`);
        }


        logger.info(`Successfully generated and parsed ${questions.length} ${type} questions.`);
        return questions;

    } catch (error: any) {
         logger.error(`Error during AI question generation or parsing for ${type}:`, error.message);
         // Log the prompt that failed if possible (be mindful of size limits)
         // logger.error("Failed Prompt (truncated):", prompt.substring(0, 1000));
         throw error; // Rethrow to be handled by the calling Cloud Function
    }
}

```

**5. `functions/src/manageModuleContent/index.ts`**

```typescript
import * as functions from 'firebase-functions';
import { logger, db, serverTimestamp } from '../config/config';
import { readFromStorage } from '../utils/storageUtils';
import { ManageModuleInput, Module, Section } from '../types'; // Import types
import { HttpsError } from 'firebase-functions/v2/https'; // Use v2 HttpsError


// Define runtime options if needed (e.g., memory, timeout)
const runtimeOpts: functions.RuntimeOptions = {
    timeoutSeconds: 120, // Increased timeout for storage reads/writes
    memory: '512MB',   // Adjust memory as needed
};

/**
 * HTTP Cloud Function to create or update a module and its sections.
 * Expects JSON payload matching ManageModuleInput.
 */
export const manageModuleContent = functions.runWith(runtimeOpts)
    .https.onCall(async (data: ManageModuleInput, context): Promise<{ success: boolean; message: string; moduleId: string }> => {

    // Basic Authentication/Authorization (Example: Allow only authenticated users)
    // You might want more specific role-based access control in a real app
    if (!context.auth) {
        logger.error('User is not authenticated.');
        throw new HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }
    // TODO: Add role check if needed: check context.auth.token.role === 'admin'

    logger.info(`Received request to manage module: ${data.moduleId}`, { uid: context.auth.uid });

    // Validate input data
    if (!data.moduleId || !data.title || !data.description || !data.sections || data.sections.length === 0) {
         logger.error('Invalid input data:', data);
         throw new HttpsError('invalid-argument', 'Missing required fields: moduleId, title, description, and at least one section.');
    }
    data.sections.forEach((s, i) => {
        if (!s.title || !s.contentStoragePath || typeof s.order !== 'number') {
             logger.error(`Invalid section data at index ${i}:`, s);
             throw new HttpsError('invalid-argument', `Invalid section data at index ${i}. Missing title, contentStoragePath, or order.`);
        }
    });


    const moduleRef = db.collection('modules').doc(data.moduleId);
    const sectionsCollectionRef = moduleRef.collection('sections');
    const batch = db.batch(); // Use a batch for atomic writes

    try {
        // 1. Prepare Module Data
        const moduleDocData: Partial<Module> = {
            moduleId: data.moduleId,
            title: data.title,
            description: data.description,
            duration: data.duration ?? null,
            prerequisites: data.prerequisites || [],
            contentType: 'markdown', // Assuming Markdown for now
            updatedAt: serverTimestamp(),
            // quizIds will be added by the quiz generation function
        };
        // Use set with merge to create or update, preserving createdAt and quizIds
        batch.set(moduleRef, moduleDocData, { merge: true });
        logger.info(`Prepared module metadata for batch set/merge: ${data.moduleId}`);


        // 2. Process Sections - Read from Storage and Add to Batch
        const sectionsToUpload: Section[] = [];
        for (const secInput of data.sections) {
            try {
                 logger.info(`Reading section content from: ${secInput.contentStoragePath}`);
                 const mdContent = await readFromStorage(secInput.contentStoragePath);

                 const sectionId = `section-${String(secInput.order).padStart(3, '0')}`; // Consistent ID format
                 const sectionDocData: Section = {
                    id: sectionId,
                    title: secInput.title,
                    content: mdContent, // Content read from GCS
                    order: secInput.order,
                    moduleId: data.moduleId,
                    updatedAt: serverTimestamp(),
                    // Add createdAt only if creating? Firestore handles this with serverTimestamp() on create.
                 };
                 sectionsToUpload.push(sectionDocData);
                 // Overwrite section in subcollection
                 const sectionRef = sectionsCollectionRef.doc(sectionId);
                 batch.set(sectionRef, sectionDocData); // Set will overwrite or create
                 logger.info(`Prepared section for batch set: ${sectionId} (Order: ${secInput.order})`);

            } catch (storageError: any) {
                logger.error(`Failed to read or prepare section (Path: ${secInput.contentStoragePath}):`, storageError.message);
                // Decide: fail the whole operation or skip this section?
                // Throwing will abort the batch.
                throw new HttpsError('internal', `Failed to process section content from ${secInput.contentStoragePath}: ${storageError.message}`);
            }
        }

         // OPTIONAL: Delete old sections not present in the new input?
         // This requires listing existing sections and comparing IDs, adds complexity.
         // For now, we just overwrite based on the input.


        // 3. Commit Batch
        logger.info(`Committing batch for module ${data.moduleId} with ${sectionsToUpload.length} sections...`);
        await batch.commit();
        logger.info(`Successfully created/updated module ${data.moduleId} and its sections.`);

        return {
            success: true,
            message: `Module ${data.moduleId} processed successfully with ${sectionsToUpload.length} sections.`,
            moduleId: data.moduleId,
        };

    } catch (error: any) {
        logger.error(`Error processing module ${data.moduleId}:`, error);
        if (error instanceof HttpsError) {
            throw error; // Rethrow HttpsError directly
        }
        // Throw a generic internal error for unexpected issues
        throw new HttpsError('internal', `An unexpected error occurred while processing module ${data.moduleId}.`);
    }
});

```

**6. `functions/src/generateQuiz/index.ts`**

```typescript
import *.functions from 'firebase-functions';
import { logger, db, serverTimestamp } from '../config/config';
import { getQuizContentContext, generateAIQuestions } from '../utils/aiUtils';
import { GenerateQuizInput, Quiz } from '../types'; // Import types
import { HttpsError } from 'firebase-functions/v2/https';
import { FieldValue } from 'firebase-admin/firestore'; // Import FieldValue

// Define runtime options if needed (consider AI call duration)
const runtimeOpts: functions.RuntimeOptions = {
    timeoutSeconds: 300, // Generous timeout for AI generation
    memory: '1GB',      // More memory might be needed for context/AI libs
};

/**
 * HTTP Cloud Function to generate quiz questions for a module.
 * Expects JSON payload matching GenerateQuizInput.
 */
export const generateQuiz = functions.runWith(runtimeOpts)
    .https.onCall(async (data: GenerateQuizInput, context): Promise<{ success: boolean; message: string; quizId: string; questionCount: number }> => {

    // Authentication/Authorization (Example)
    if (!context.auth) {
        logger.error('User is not authenticated.');
        throw new HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }
    // TODO: Add role check if needed

    logger.info(`Received request to generate quiz: ${data.quizId} for module: ${data.moduleId}`, { uid: context.auth.uid });

    // Validate input
    if (!data.quizId || !data.moduleId || !data.title || !data.numberOfQuestions || data.numberOfQuestions <= 0 || !data.passingScore) {
        logger.error('Invalid input data for generateQuiz:', data);
        throw new HttpsError('invalid-argument', 'Missing required fields or invalid values: quizId, moduleId, title, numberOfQuestions (>0), passingScore.');
    }

    const quizRef = db.collection('quizzes').doc(data.quizId);
    const moduleRef = db.collection('modules').doc(data.moduleId);

    try {
        // 1. Get Module Content Context
        logger.info(`Workspaceing content context for module ${data.moduleId}...`);
        const moduleContentContext = await getQuizContentContext(data.moduleId);

        // 2. Construct AI Prompt
        // Refine this prompt based on experimentation for best results
        const prompt = `Generate exactly ${data.numberOfQuestions} multiple-choice (A, B, C, D) quiz questions with one correct answer and a brief explanation for each, based on the following content about "${data.title}":\n\nContent:\n"""${moduleContentContext}"""\n\nFormat each question like this:\n<Question Number>. <Question Text>\nA) <Answer A>\nB) <Answer B>\nC) <Answer C>\nD) <Answer D>\nCorrect Answer: <Correct Letter (A, B, C, or D)>\nExplanation: <Brief explanation why the answer is correct>\n\n---\n`; // Add separators if needed

        // 3. Generate Questions using AI Util
        logger.info(`Generating ${data.numberOfQuestions} questions for quiz ${data.quizId}...`);
        const questions = await generateAIQuestions(prompt, data.numberOfQuestions, 'quiz');

        // 4. Prepare Quiz Data
        const quizData: Partial<Quiz> = {
            quizId: data.quizId,
            moduleId: data.moduleId,
            title: data.title,
            passingScore: data.passingScore,
            questions: questions, // Generated questions
            updatedAt: serverTimestamp(),
        };

        // 5. Save Quiz to Firestore (Set with merge to create/overwrite)
        logger.info(`Saving generated quiz ${data.quizId} to Firestore...`);
        await quizRef.set(quizData, { merge: true });

        // 6. Update Module with Quiz ID link (using arrayUnion for idempotency)
        logger.info(`Linking quiz ${data.quizId} to module ${data.moduleId}...`);
        await moduleRef.update({
            quizIds: FieldValue.arrayUnion(data.quizId) // Add quizId if not already present
        }); // Use update here, assuming module exists

        logger.info(`Successfully generated and saved quiz ${data.quizId} with ${questions.length} questions.`);

        return {
            success: true,
            message: `Quiz ${data.quizId} generated successfully with ${questions.length} questions.`,
            quizId: data.quizId,
            questionCount: questions.length,
        };

    } catch (error: any) {
        logger.error(`Error generating quiz ${data.quizId}:`, error);
        if (error instanceof HttpsError) {
            throw error;
        }
        if (error.message?.includes('Module definition not found')) {
             throw new HttpsError('not-found', `Module ${data.moduleId} not found. Cannot generate quiz.`);
        }
         if (error.message?.includes('No content context')) {
             throw new HttpsError('failed-precondition', `Could not retrieve content for module ${data.moduleId}.`);
        }
        // Throw a generic internal error
        throw new HttpsError('internal', `An unexpected error occurred while generating quiz ${data.quizId}.`);
    }
});
```

**7. `functions/src/generateExam/index.ts`**

```typescript
import * as functions from 'firebase-functions';
import { logger, db, serverTimestamp } from '../config/config';
import { getExamContentContext, generateAIQuestions } from '../utils/aiUtils';
import { GenerateExamInput, Exam } from '../types'; // Import types
import { HttpsError } from 'firebase-functions/v2/https';

// Define runtime options (Exams might need more resources/time)
const runtimeOpts: functions.RuntimeOptions = {
    timeoutSeconds: 540, // Longer timeout for potentially large context/more questions
    memory: '1GB',      // More memory
};

/**
 * HTTP Cloud Function to create/update exam metadata and generate questions.
 * Expects JSON payload matching GenerateExamInput.
 */
export const generateExam = functions.runWith(runtimeOpts)
    .https.onCall(async (data: GenerateExamInput, context): Promise<{ success: boolean; message: string; examId: string; questionCount: number }> => {

    // Authentication/Authorization (Example)
    if (!context.auth) {
        logger.error('User is not authenticated.');
        throw new HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }
    // TODO: Add role check if needed

    logger.info(`Received request to generate exam: ${data.examId}`, { uid: context.auth.uid });

    // Validate input
    if (!data.examId || !data.title || !data.description || !data.numberOfQuestions || data.numberOfQuestions <= 0) {
        logger.error('Invalid input data for generateExam:', data);
        throw new HttpsError('invalid-argument', 'Missing required fields or invalid values: examId, title, description, numberOfQuestions (>0).');
    }

    const examRef = db.collection('exams').doc(data.examId);

    try {
        // 1. Create or Update Exam Metadata
        logger.info(`Setting/merging exam metadata for ${data.examId}...`);
        const examMetaData: Partial<Exam> = {
            examId: data.examId,
            title: data.title,
            description: data.description,
            duration: data.duration ?? null,
            prerequisites: data.prerequisites || [],
            associatedModules: data.associatedModules || [],
            updatedAt: serverTimestamp(),
            // questions and questionsGeneratedAt will be added after generation
        };
        await examRef.set(examMetaData, { merge: true }); // Create or update metadata

        // 2. Get Exam Content Context (using associated modules)
        logger.info(`Workspaceing content context for exam ${data.examId}...`);
        const examContentContext = await getExamContentContext(data.examId); // Fetches based on associatedModules in Firestore

         if (!examContentContext || examContentContext.length < 50) { // Check context length
            logger.warn(`Insufficient content context generated for exam ${data.examId}. Generation might be less accurate.`);
            // Decide if this should be an error or just a warning
        }


        // 3. Construct AI Prompt
        // Refine prompt for exam-style questions (potentially more complex/scenario-based)
        const prompt = `Generate exactly ${data.numberOfQuestions} challenging, multiple-choice (A, B, C, D) exam questions with one correct answer and a brief explanation for each, suitable for an exam titled "${data.title}". Base the questions on the following comprehensive content including associated module details:\n\nContent:\n"""${examContentContext}"""\n\nFormat each question strictly like this:\n<Question Number>. <Question Text>\nA) <Answer A>\nB) <Answer B>\nC) <Answer C>\nD) <Answer D>\nCorrect Answer: <Correct Letter (A, B, C, or D)>\nExplanation: <Brief explanation why the answer is correct>\n\n---\n`;

        // 4. Generate Questions using AI Util
        logger.info(`Generating ${data.numberOfQuestions} questions for exam ${data.examId}...`);
        const questions = await generateAIQuestions(prompt, data.numberOfQuestions, 'exam');

        // 5. Update Exam Document with Questions
        logger.info(`Saving generated questions to exam document ${data.examId}...`);
        await examRef.update({ // Use update as metadata was set previously
            questions: questions,
            questionsGeneratedAt: serverTimestamp(),
            updatedAt: serverTimestamp() // Update timestamp again
        });

        logger.info(`Successfully generated and saved exam ${data.examId} with ${questions.length} questions.`);

        return {
            success: true,
            message: `Exam ${data.examId} generated successfully with ${questions.length} questions.`,
            examId: data.examId,
            questionCount: questions.length,
        };

    } catch (error: any) {
        logger.error(`Error generating exam ${data.examId}:`, error);
        if (error instanceof HttpsError) {
            throw error;
        }
        if (error.message?.includes('Exam definition not found')) {
             // This shouldn't happen if set merge worked, but handle defensively
             throw new HttpsError('not-found', `Exam metadata for ${data.examId} could not be established.`);
        }
        // Throw a generic internal error
        throw new HttpsError('internal', `An unexpected error occurred while generating exam ${data.examId}.`);
    }
});
```

**8. `functions/src/index.ts` (Main Entry Point)**

```typescript
// Export all Cloud Functions from their respective files

export { manageModuleContent } from './manageModuleContent';
export { generateQuiz } from './generateQuiz';
export { generateExam } from './generateExam';

// You can also export other functions (like email, auth triggers) from here
// export * from './email'; // Assuming email.js is refactored to TS
// export * from './auth';  // Assuming auth.js is refactored to TS
```

---

Remember to replace placeholder logic (especially `parseQuizFromAIResponse`) with your actual implementation details. Test thoroughly, especially the AI parsing and Cloud Storage interactions.
